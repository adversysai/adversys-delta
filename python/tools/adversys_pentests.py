"""
CUSTOM ADDITION: Adversys Penetration Test Tool
================================================
This file is a custom addition to Delta for Adversys Core integration.
It provides tools for managing and executing penetration tests in Adversys Core.

This is NOT part of the upstream Delta codebase.
"""
import json
from typing import Optional
from python.helpers.tool import Tool, Response
from python.helpers.print_style import PrintStyle
from python.tools.adversys_api_tool import AdversysAPI


class AdversysPentests(AdversysAPI):
    """Tool for managing Adversys penetration tests"""
    
    async def execute(self, **kwargs) -> Response:
        """Execute penetration test operation"""
        operation = self.args.get("operation", "").lower()
        
        if operation == "create":
            return await self._create_pentest()
        elif operation == "start":
            return await self._start_pentest()
        elif operation == "status":
            return await self._get_pentest_status()
        elif operation == "pause":
            return await self._pause_pentest()
        elif operation == "resume":
            return await self._resume_pentest()
        elif operation == "approve_exploit":
            return await self._approve_exploit()
        elif operation == "list":
            return await self._list_pentests()
        else:
            return Response(
                message=f"Unknown operation: {operation}. Valid operations: create, start, status, pause, resume, approve_exploit, list",
                break_loop=False
            )
    
    def _check_missing_config(self, roe: dict, scope: dict) -> list[str]:
        """Check what configuration questions need to be asked"""
        missing = []
        
        # Check if destructive operations are specified
        if "destructive" not in roe or roe.get("destructive") is None:
            missing.append("destructive_operations")
        
        # Check if approval requirement is specified
        if "requires_approval" not in roe or roe.get("requires_approval") is None:
            missing.append("approval_requirement")
        
        # Check if noise level is specified
        if "noise_level" not in roe or roe.get("noise_level") is None:
            missing.append("noise_level")
        
        # Check if test intensiveness is specified (in ROE, not scope)
        if "intensiveness" not in roe or roe.get("intensiveness") is None:
            missing.append("test_intensiveness")
        
        # Check if out of scope targets are specified
        # Check both new format (excluded_targets in roe) and old format (out_of_scope_targets in scope)
        has_excluded_targets = "excluded_targets" in roe
        has_out_of_scope_targets = "out_of_scope_targets" in scope

        if not has_excluded_targets and not has_out_of_scope_targets:
            missing.append("out_of_scope_targets")
        
        return missing
    
    async def _create_pentest(self) -> Response:
        """Create a new penetration test"""
        name = self.args.get("name", "")
        target_id = self.args.get("target_id", "")
        test_type = self.args.get("test_type", "black_box")
        
        if not name or not target_id:
            return Response(
                message="Missing required parameters: name and target_id are required",
                break_loop=False
            )
        
        # Validate target exists before proceeding (saves tokens by catching 404 early)
        try:
            resp = self.api_client.get(f"/api/v1/targets/{target_id}")
            if resp.status_code == 404:
                return Response(
                    message=f"Target not found: {target_id}. Please verify the target exists or create it first using the adversys_targets tool.",
                    break_loop=False
                )
            elif resp.status_code != 200:
                return Response(
                    message=f"Failed to validate target: API returned status {resp.status_code}. {resp.text[:200]}",
                    break_loop=False
                )
        except Exception as e:
            # If validation fails, continue anyway (might be network issue)
            print(f"WARNING: Could not validate target existence: {e}")
        
        # Build ROE (Rules of Engagement) - use defaults if not provided
        roe_str = self.args.get("roe", "{}")
        try:
            roe = json.loads(roe_str) if isinstance(roe_str, str) else roe_str
        except:
            roe = {"destructive": False, "time_windows": [], "excluded_targets": [], "allowed_techniques": []}
        
        # Build scope - use defaults if not provided
        scope_str = self.args.get("scope", "{}")
        try:
            if isinstance(scope_str, str):
                scope = json.loads(scope_str) if scope_str.strip() else {}
            else:
                scope = scope_str if scope_str else {}
        except:
            scope = {}
        
        # Ensure scope is a dict
        if not isinstance(scope, dict):
            scope = {}
        
        # Ensure targets field exists and includes the target_id (required by API)
        # This MUST be done before checking missing_config to prevent 422 errors
        if "targets" not in scope:
            scope["targets"] = []
        
        # Normalize targets to be a list of strings (API requires strings, not objects)
        if not isinstance(scope["targets"], list):
            scope["targets"] = []
        
        # Convert any target objects to strings (handle cases where agent passes {"id": "..."})
        normalized_targets = []
        for t in scope["targets"]:
            if isinstance(t, dict):
                # Extract ID from object if present
                t_id = t.get("id") or t.get("target_id") or str(t)
                normalized_targets.append(str(t_id))
            elif t is not None:
                normalized_targets.append(str(t))
        scope["targets"] = normalized_targets
        
        # Ensure target_id is in the targets list (API requires this)
        # This is critical - the API will return 422 if targets is missing or doesn't include target_id
        if target_id and target_id not in scope["targets"]:
            scope["targets"].append(target_id)
        
        # Debug: Log normalized scope to help troubleshoot
        if not scope.get("targets"):
            print(f"WARNING: Scope targets is empty after normalization for target_id: {target_id}")
        else:
            print(f"DEBUG: Normalized scope.targets to: {scope['targets']} (target_id: {target_id})")
        
        # Check if we need to ask configuration questions
        missing_config = self._check_missing_config(roe, scope)
        
        if missing_config:
            questions = []
            if "destructive_operations" in missing_config:
                questions.append("• Are destructive operations allowed? (yes/no) - Operations that may cause data loss or service disruption")
            if "approval_requirement" in missing_config:
                questions.append("• Should exploits require approval before execution? (yes/no) - This adds a safety check before running potentially risky exploits")
            if "noise_level" in missing_config:
                questions.append("• What noise level should be used? (silent/low/medium/high) - Controls how detectable the testing activities are")
            if "test_intensiveness" in missing_config:
                questions.append("• What test intensiveness level? (quick/standard/thorough/exhaustive) - Controls how thorough and comprehensive the testing will be")
            if "out_of_scope_targets" in missing_config:
                questions.append("• Are there any out-of-scope targets that should be excluded? (yes/no) - If yes, please specify which targets (domains, IPs, or ranges) should not be tested")
            
            message = f"Before creating the penetration test '{name}', I need to clarify a few configuration details:\n\n"
            message += "\n".join(questions)
            message += "\n\nPlease provide answers to these questions so I can configure the test appropriately."
            
            return Response(
                message=message,
                break_loop=False,
                additional={"needs_config": True, "missing_config": missing_config}
            )
        
        # Auto-enable verify_out_of_scope if excluded_targets or out_of_scope_targets are provided
        excluded_targets = roe.get("excluded_targets", [])
        out_of_scope_targets = scope.get("out_of_scope_targets", [])

        # Handle both new format (excluded_targets in roe) and old format (out_of_scope_targets in scope)
        total_excluded = len(excluded_targets) + len(out_of_scope_targets)
        if total_excluded > 0:
            scope["verify_out_of_scope"] = True
            print(f"DEBUG: Auto-enabled verify_out_of_scope because {total_excluded} excluded target(s) specified")

        # For backward compatibility, if old format is used, copy to new format
        if out_of_scope_targets and not excluded_targets:
            roe["excluded_targets"] = out_of_scope_targets
            print(f"DEBUG: Copied out_of_scope_targets to excluded_targets for API compatibility")
        
        # All configuration provided, proceed with creation
        pentest_data = {
            "name": name,
            "target_id": target_id,
            "test_type": test_type,
            "roe": roe,
            "scope": scope
        }
        
        resp = self.api_client.post("/api/v1/pentests/", json_data=pentest_data)
        return self._handle_api_response(resp, f"Penetration test '{name}' created successfully")
    
    async def _start_pentest(self) -> Response:
        """Start a penetration test"""
        test_id = self.args.get("test_id", "")
        
        if not test_id:
            return Response(
                message="Missing required parameter: test_id",
                break_loop=False
            )
        
        resp = self.api_client.post(f"/api/v1/pentests/{test_id}/start", json_data={})
        return self._handle_api_response(resp, f"Penetration test {test_id} started")
    
    async def _get_pentest_status(self) -> Response:
        """Get penetration test status and progress"""
        test_id = self.args.get("test_id", "")
        
        if not test_id:
            return Response(
                message="Missing required parameter: test_id",
                break_loop=False
            )
        
        resp = self.api_client.get(f"/api/v1/pentests/{test_id}")
        
        try:
            resp.raise_for_status()
            test = resp.json()
            
            message = f"Penetration Test: {test.get('name', 'Unknown')}\n"
            message += f"Status: {test.get('status', 'Unknown')}\n"
            message += f"Progress: {test.get('progress_percent', 0)}%\n"
            message += f"Current Phase: {test.get('current_phase', 'N/A')}\n"
            message += f"Current Module: {test.get('current_module', 'N/A')}\n"
            message += f"Modules Completed: {test.get('modules_completed', 0)}/{test.get('modules_total', 0)}\n"
            
            if test.get('is_waiting_approval'):
                pending = test.get('pending_exploit_approval', {})
                if pending:
                    module_name = pending.get('module_name', pending.get('module_id', 'N/A'))
                    finding_title = pending.get('finding_title', 'N/A')
                    risk_level = pending.get('risk_level', 'N/A')
                    description = pending.get('description', 'N/A')
                    execution_id = pending.get('execution_id', '')
                    
                    message += f"\n\n⚠️ ACTION REQUIRED: Exploit Approval Needed\n"
                    message += f"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                    message += f"Module: {module_name}\n"
                    message += f"Finding: {finding_title}\n"
                    message += f"Risk Level: {risk_level}\n"
                    if description:
                        message += f"Description: {description}\n"
                    message += f"\nThe penetration test is waiting for your approval to execute this exploit.\n"
                    message += f"Please respond with:\n"
                    message += f"  • 'yes' or 'approve' to allow the exploit execution\n"
                    message += f"  • 'no' or 'reject' to skip this exploit\n"
                    message += f"\nTo approve, use: adversys_pentests with operation='approve_exploit', test_id='{test_id}'\n"
                    message += f"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                    
                    return Response(
                        message=message,
                        break_loop=False,
                        additional={"needs_approval": True, "test_id": test_id, "execution_id": execution_id}
                    )
            
            return Response(message=message, break_loop=False)
        except Exception as e:
            return self._handle_api_response(resp, "Failed to get penetration test status")
    
    async def _pause_pentest(self) -> Response:
        """Pause a running penetration test"""
        test_id = self.args.get("test_id", "")
        
        if not test_id:
            return Response(
                message="Missing required parameter: test_id",
                break_loop=False
            )
        
        resp = self.api_client.post(f"/api/v1/pentests/{test_id}/pause", json_data={})
        return self._handle_api_response(resp, f"Penetration test {test_id} paused")
    
    async def _resume_pentest(self) -> Response:
        """Resume a paused penetration test"""
        test_id = self.args.get("test_id", "")
        
        if not test_id:
            return Response(
                message="Missing required parameter: test_id",
                break_loop=False
            )
        
        resp = self.api_client.post(f"/api/v1/pentests/{test_id}/resume", json_data={})
        return self._handle_api_response(resp, f"Penetration test {test_id} resumed")
    
    async def _approve_exploit(self) -> Response:
        """Approve an exploit execution"""
        test_id = self.args.get("test_id", "")
        execution_id = self.args.get("execution_id", "")
        
        if not test_id:
            return Response(
                message="Missing required parameter: test_id",
                break_loop=False
            )
        
        # Build request data - execution_id is optional
        request_data = {}
        if execution_id:
            request_data["execution_id"] = execution_id
        
        resp = self.api_client.post(
            f"/api/v1/pentests/{test_id}/approve-exploit",
            json_data=request_data if request_data else {}
        )
        return self._handle_api_response(resp, f"Exploit approved for test {test_id}. The test will continue execution.")
    
    async def _list_pentests(self) -> Response:
        """List all penetration tests"""
        resp = self.api_client.get("/api/v1/pentests/")
        
        try:
            resp.raise_for_status()
            tests = resp.json()
            
            if not tests:
                return Response(message="No penetration tests found", break_loop=False)
            
            # Format tests list
            message = f"Found {len(tests)} penetration test(s):\n\n"
            for test in tests:
                message += f"- {test.get('name', 'Unknown')} (ID: {test.get('id', 'N/A')})\n"
                message += f"  Status: {test.get('status', 'N/A')}, Progress: {test.get('progress_percent', 0)}%\n"
                message += f"  Type: {test.get('test_type', 'N/A')}\n"
                message += "\n"
            
            return Response(message=message.strip(), break_loop=False)
        except Exception as e:
            return self._handle_api_response(resp, "Failed to list penetration tests")
